Questão 11:
#include <stdio.h>

int main() {
    // Endereço inicial do vetor x
    int endereco_inicial = 4092;

    // Tamanhos dos tipos de dados
    int tamanho_char = 1;
    int tamanho_int = 2;
    int tamanho_float = 4;
    int tamanho_double = 8;

    // Calculando os deslocamentos para cada tipo de dado
    int endereco_char = endereco_inicial + tamanho_char;
    int endereco_int = endereco_inicial + tamanho_int;
    int endereco_float = endereco_inicial + tamanho_float;
    int endereco_double = endereco_inicial + tamanho_double;

    // Imprimindo os resultados na tela
    printf("Endereço de x_char + 1: %d\n", endereco_char);
    printf("Endereço de x_int + 1: %d\n", endereco_int);
    printf("Endereço de x_float + 1: %d\n", endereco_float);
    printf("Endereço de x_double + 1: %d\n", endereco_double);
    printf("\n");

    printf("Endereço de x_char + 2: %d\n", endereco_char + tamanho_char);
    printf("Endereço de x_int + 2: %d\n", endereco_int + tamanho_int);
    printf("Endereço de x_float + 2: %d\n", endereco_float + tamanho_float);
    printf("Endereço de x_double + 2: %d\n", endereco_double + tamanho_double);
    printf("\n");

    printf("Endereço de x_char + 3: %d\n", endereco_char + 2 * tamanho_char);
    printf("Endereço de x_int + 3: %d\n", endereco_int + 2 * tamanho_int);
    printf("Endereço de x_float + 3: %d\n", endereco_float + 2 * tamanho_float);
    printf("Endereço de x_double + 3: %d\n", endereco_double + 2 * tamanho_double);
    printf("\n");

    return 0;
}


    return 0;
}

///////////
Questão 12:

Vamos analisar cada comando e determinar se é válido ou inválido:
1. aloha[2] = value;: Válido. Isso atribui o valor da variável value ao terceiro elemento do array aloha. Ambos aloha[2] e value são do tipo float.
2. scanf("%f", &aloha);: Inválido. A função scanf() espera um ponteiro para uma variável float para armazenar o valor digitado pelo usuário. No entanto, &aloha é um ponteiro para o primeiro elemento do array aloha, que é do tipo float *, não um único elemento do tipo float.
3. aloha = "value";: Inválido. Esta atribuição tenta atribuir uma string à matriz aloha, o que não é permitido. A matriz aloha é uma matriz de floats, não uma string.
4. printf("%f", aloha);: Inválido. %f é um especificador de formato para float, mas aloha é um array de floats, não um float individual. Você precisa especificar um elemento específico do array (por exemplo, aloha[0], aloha[1], etc.) para imprimir corretamente um valor float usando printf().
5. coisas[4][4] = aloha[3];: Válido. Isso atribui o valor do quarto elemento do array aloha ao elemento coisas[4][4]. Ambos aloha[3] e coisas[4][4] são do tipo float.
6. coisas[5] = aloha;: Inválido. Você não pode atribuir um array a outro array desta forma em C. coisas[5] é uma linha de uma matriz bidimensional, enquanto aloha é um array unidimensional de floats.
7. pf = value;: Inválido. pf é um ponteiro para float, e value é um float. Atribuir diretamente um float a um ponteiro para float é inválido. Você precisa atribuir o endereço de value a pf usando pf = &value;.
8. pf = aloha;: Válido. Isso atribui o endereço do primeiro elemento do array aloha ao ponteiro pf. Ambos pf e aloha são do tipo float *, então isso é válido.
/////////
Questão 13:
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    // malloc sem free
    int *ptr1 = (int *)malloc(sizeof(int));

    // loop com malloc sem free
    for (int i = 0; i < 5; i++) {
        int *ptr2 = (int *)malloc(sizeof(int));
    }

    // nullptr
    int *ptr3 = (int *)malloc(sizeof(int));
    ptr3 = NULL; // Em C, usamos NULL em vez de nullptr
    return 0;
}
Memory leak é um problema no qual um programa aloca memória dinamicamente, mas não libera a memória que não é mais utilizada gerando um baixo desepenho da máquina.
/////
Questão 14:
Ponteiro para uma função é um recurso que serve para definif, ou chamar, qual função será executada, sem a necessidade de escrever o nome da função, de forma explícita todas as vezes. 
exemplo:
#include <stdio.h>

  void troca(int a, int b){
    int tmp;
    printf("a = %d, b = %d\n", a, b);
    tmp = a; a = b; tmp = b;
    printf("a = %d, b = %d\n", a, b);
  }
int main(void){
  int x = 3, y = 4;
  printf("x = %d, y = %d\n", x, y);
  troca(x, y);
  printf("x = %d, y = %d\n", x, y);
  return 0;
}
////
Questão 15:
#include <stdio.h>
#include <stdlib.h> 

// Função de comparação
int compare(const void *p1, const void *p2) {
    float float_p1 = *((float *)p1);
    float float_p2 = *((float *)p2);
    if (float_p1 < float_p2) return -1;
    if (float_p1 > float_p2) return 1;
    return 0;
}

// Função para ordenar os floats
void ordenar_float(int X) {
    float *floats = (float *)malloc(X * sizeof(float));
    if (floats == NULL) {
        printf("Erro de alocação de memória para floats.\n");
        return;
    }

    printf("Digite os %d valores:\n", X);
    for (int i = 0; i < X; i++) {
        scanf("%f", &floats[i]);
    }

    // qsort
    qsort(floats, X, sizeof(float), compare);

    // Apresentação dos valores em ordem crescente
    printf("Floats em ordem crescente:\n"); 
    for (int i = 0; i < X; i++) {
        printf("%.2f ", floats[i]);
    }
    printf("\n");

    free(floats);
}

int main() {
    int X;
    printf("Digite a quantidade de valores: ");
    scanf("%d", &X);
    ordenar_float(X);
    return 0;
}
/////
Questão 16:
O código já se utiliza do qsort, então, irei explicar sua função nesse código. O qsort foi usado na linha "125" para a ordenação dos floats, explicando cada um: 
1 - "floats" - Meu ponteiro para um array
2 - "X" - É o número de elementos do array 
3 - "sizeof(float)" - indica o tamanho de cada elemento do array em bytes. Um float possui 4 bytes
4 - "Compare" - Função que serve de comparação, que irá imprimir "1" para valores válidos e "-1" para os inválidos.
//////
Questão 17:
Questão 18:
Questão 19:
#include <stdio.h>

// Função para somar vetores e armazenar o resultado em um terceiro vetor
void soma_vetores(int *vet1, int *vet2, int *resultado, int tamanho) {
    for (int i = 0; i < tamanho; i++) {
        resultado[i] = vet1[i] + vet2[i];
    }
}

int main() {
    int tamanho;

    // Solicita o tamanho dos vetores ao usuário
    printf("Digite o tamanho dos vetores: ");
    scanf("%d", &tamanho);

    // Declaração dos vetores
    int vet1[tamanho], vet2[tamanho], resultado[tamanho];

    // Solicita os elementos do primeiro vetor ao usuário
    printf("Digite os elementos do primeiro vetor:\n");
    for (int i = 0; i < tamanho; i++) {
        scanf("%d", &vet1[i]);
    }

    // Solicita os elementos do segundo vetor ao usuário
    printf("Digite os elementos do segundo vetor:\n");
    for (int i = 0; i < tamanho; i++) {
        scanf("%d", &vet2[i]);
    }

    // função soma_vetores para realizar a soma e armazenar o resultado
    soma_vetores(vet1, vet2, resultado, tamanho);

    // vetor resultado
    printf("Resultado da soma dos vetores:\n");
    for (int i = 0; i < tamanho; i++) {
        printf("%d ", resultado[i]);
    }
    printf("\n");

    return 0;
}

















Questão 20;







